/*
 * Copyright Â© 2021, 2022, 2023, 2024, 2025 Peter Doornbosch
 *
 * This file is part of Kwik, an implementation of the QUIC protocol in Java.
 *
 * Kwik is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * Kwik is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package tech.kwik.core.server.impl;

import tech.kwik.agent15.TlsProtocolException;
import tech.kwik.agent15.handshake.ClientHello;
import tech.kwik.core.common.EncryptionLevel;
import tech.kwik.core.crypto.Aead;
import tech.kwik.core.crypto.ConnectionSecrets;
import tech.kwik.core.crypto.CryptoStream;
import tech.kwik.core.crypto.MissingKeysException;
import tech.kwik.core.frame.CryptoFrame;
import tech.kwik.core.frame.Padding;
import tech.kwik.core.frame.PingFrame;
import tech.kwik.core.frame.QuicFrame;
import tech.kwik.core.impl.*;
import tech.kwik.core.log.Logger;
import tech.kwik.core.log.NullLogger;
import tech.kwik.core.packet.DatagramFilter;
import tech.kwik.core.packet.InitialPacket;
import tech.kwik.core.packet.PacketMetaData;
import tech.kwik.core.server.ServerConnectionFactory;
import tech.kwik.core.server.ServerConnectionRegistry;
import tech.kwik.core.util.Bytes;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A server connection candidate: whether an initial packet causes a new server connection to be created will not be
 * decided until the initial packet has been successfully parsed and decrypted (to avoid that corrupt packets change
 * server state).
 *
 * <p>
 * When an initial packet with an unknown destination connection ID arrives, a ServerConnectionCandidate is created,
 * to avoid that ServerConnection objects are create for invalid packets. However, this candidate is registered in the
 * ServerConnectionRegistry, because additional initial packets with the same destination connection ID might arrive, even
 * while still processing the first, and obviously these should not lead to another ServerConnectionCandidate being created,
 * but must be delivered to the same connection (even if still a candidate).
 * Note that this candidate is registered with the original destination connection ID and that only _initial_ packets with
 * this connection ID are allowed, hence the InitialPacketFilterProxy.
 * If additional initial packets with the original destination connection ID arrive, the server candidate will pass
 * them through to the final connection.
 * If the initial packet did not lead to a server connection, the entry with the ODCID will be removed after some time. </o>
 * <p>
 * Now the connection candidate will parse the initial packet, but on a different thread (to limit usage of the thread that
 * is receiving UDP datagrams). If the packet is valid, the candidate creates the final connection and registers this in
 * the ServerConnectionRegistry, but with the new connection ID that is generated by the server connection itself.
 * The server connection is wrapped by a ServerConnectionThread (to ensure that minimal processing is done on the receiver
 * thread and that all processing for a server connection is done on the same thread (to enable thread-confinement strategy))
 * and by a filter chain that does a lot of processing before the packet is delivered to the connection. </p>
 * <p>
 * So, effectively, for each connection the registry will contain:
 * <pre>
 * - ODCID -> InitialPacketFilterProxy -> ServerConnectionCandidate [ -> filter-chain -> adapter -> ServerConnectionThread -> ServerConnectionImpl ]
 * -   CID -> ServerConnectionWrapper -> filter-chain -> adapter -> ServerConnectionThread -> ServerConnectionImpl
 *                                     \- - - - - - - - - - - - -/
 * </pre>
 * When new connection IDs are sent to the peer, additional entries will be added to the registry to ensure these new
 * connection IDs also map to the same connection. </p>
 */
public class ServerConnectionCandidate implements ServerConnectionProxy, DatagramFilter {

    // Minimum length for initial crypto frames, except for the last one (which of course is allowed to be shorter)
    // A value close to (1200 - packet overhead) would make a lot of sense, but at least in interop tests, some
    // implementations like to test scenario's with smaller Client Hello parts. To support these, a smaller value is chosen.
    public static final int MINIMUM_NON_FINAL_CRYPTO_LENGTH = 700;

    private final Version quicVersion;
    private final InetSocketAddress clientAddress;
    private final byte[] scid;
    private final byte[] dcid;
    private final ServerConnectionFactory serverConnectionFactory;
    private final ServerConnectionRegistry connectionRegistry;
    private final Logger log;
    private final DatagramFilter filterChain;
    private final ReentrantLock registrationLock;
    private final ScheduledFuture<?> cleanupTask;
    private volatile ServerConnectionProxy registeredConnection;
    private final ExecutorService executor;
    private final ScheduledExecutorService scheduledExecutor;
    private volatile boolean closed;
    private final CryptoStream cryptoBuffer;
    private final List<InitialPacket> bufferedInitialPackets = new ArrayList<>();
    private int bufferedDatagramDataSize;
    private volatile boolean inError;


    public ServerConnectionCandidate(Context context, Version version, InetSocketAddress clientAddress, byte[] scid, byte[] dcid,
                                     ServerConnectionFactory serverConnectionFactory, ServerConnectionRegistry connectionRegistry, Logger log) {
        this.executor = context.getSharedServerExecutor();
        this.scheduledExecutor = context.getSharedScheduledExecutor();
        this.quicVersion = version;
        this.clientAddress = clientAddress;
        this.scid = scid;
        this.dcid = dcid;
        this.serverConnectionFactory = serverConnectionFactory;
        this.connectionRegistry = connectionRegistry;
        this.log = log;

        filterChain =
                new ClientAddressFilter(clientAddress, log,
                        new ClientInitialScidFilter(scid, log,
                                new InitialPacketMinimumSizeFilter(log, this)));
        registrationLock = new ReentrantLock();

        cryptoBuffer = new CryptoStream(VersionHolder.with(quicVersion), EncryptionLevel.Initial, Role.Server, log);
        cryptoBuffer.setBufferMode();

        // The cleanup delay should be longer then the maximum connect timeout clients (are likely to) use.
        // It can be fairly large because the removal is only needed to avoid unused connection candidates pile up.
        cleanupTask = scheduledExecutor.schedule(this::removeFromConnectionRegistry, 30, TimeUnit.SECONDS);
    }

    @Override
    public byte[] getOriginalDestinationConnectionId() {
        return dcid;
    }

    @Override
    public void parsePackets(int datagramNumber, Instant timeReceived, ByteBuffer data, InetSocketAddress sourceAddress) {
        if (inError) {
            return;
        }
        // Execute packet parsing on separate thread, to make this method return a.s.a.p.
        executor.submit(() -> {
            // Serialize processing (per connection candidate): duplicate initial packets might arrive faster than they are processed.
            synchronized (this) {
                if (inError) {
                    return;
                }
                // Because of possible queueing in the executor, a connection might already exist (i.e. when multiple
                // packets queued before the connection was registered).
                if (registeredConnection != null) {
                    registeredConnection.parsePackets(datagramNumber, timeReceived, data, sourceAddress);
                    return;
                }

                try {
                    PacketMetaData metaData = new PacketMetaData(timeReceived, sourceAddress, datagramNumber);
                    filterChain.processDatagram(data, metaData);
                }
                catch (TransportError e) {
                    // Won't happen (yet), because the only filter the actually throws is the parser, which is not yet used here!
                    log.warn("Dropped initial packet due to transport error: " + e.getMessage());
                    inError = true;
                    // Clean up faster
                    cleanupTask.cancel(true);
                    scheduledExecutor.schedule(this::removeFromConnectionRegistry, 2, TimeUnit.SECONDS);
                }
            }
        });
    }

    @Override
    public void processDatagram(ByteBuffer data, PacketMetaData metaData) {
        try {
            int datagramNumber = metaData.datagramNumber();
            Instant timeReceived = metaData.timeReceived();
            InitialPacket initialPacket = parseInitialPacket(datagramNumber, timeReceived, data);
            log.received(timeReceived, datagramNumber, initialPacket);
            log.debug("Parsed packet with size " + data.position() + "; " + data.remaining() + " bytes left.");

            checkGenuineFirstFlight(initialPacket);
            bufferedInitialPackets.add(initialPacket);
            bufferedDatagramDataSize += data.limit();
            if (! checkClientHelloComplete(initialPacket)) {
                String propValue = System.getProperty("tech.kwik.core.min-crypto-data-check");
                boolean checkEnabled = propValue == null || !propValue.equalsIgnoreCase("disabled");
                if (checkEnabled && initialPacket.getFrames().stream().filter(f -> f instanceof CryptoFrame).mapToInt(f -> ((CryptoFrame) f).getLength()).sum() < MINIMUM_NON_FINAL_CRYPTO_LENGTH) {
                    throw new UnacceptablePacketException("Initial packet containing insufficient crypto data");
                }
                return;
            }

            // Packet is valid. This is the moment to create a real server connection and continue processing.
            if (registeredConnection == null) {
                createAndRegisterServerConnection(initialPacket, metaData, data, bufferedDatagramDataSize);
                cleanupTask.cancel(true);
            }
        }
        catch (InvalidPacketException | DecryptionException unacceptablePacket) {
            // Drop packet without any action (i.e. do not send anything; do not change state; avoid unnecessary processing)
            log.debug("Dropped invalid initial packet (no connection created)");
        }
        catch (TlsProtocolException | TransportError | UnacceptablePacketException invalidTlsMesssage) {
            // Trying to start a connection with data that is not a valid ClientHello message, but be a deliberate action
            log.warn("Dropped initial packet that did not contain valid CH (no connection created): "
                    + invalidTlsMesssage + " "
                    + Bytes.bytesToHex(Arrays.copyOfRange(data.array(), 0, Integer.min(data.limit(), 64))));
            // Further processing is not necessary and unwanted, as these errors can not occur accidentally.
            // This seems to create an attack vector for on-path attackers when the Client Hello does not fit in one
            // initial packet (if the attacker is able to send a second packet that arrives before the second packet
            // from the original sender), but such an attack would be possible anyway (by injecting some data in the
            // crypto stream). So, switching to error state doesn't make it worse.
            inError = true;
            // Clean up faster
            cleanupTask.cancel(true);
            scheduledExecutor.schedule(this::removeFromConnectionRegistry, 2, TimeUnit.SECONDS);
        }
    }

    /**
     * Check whether received (including buffered) crypto data already contains a complete ClientHello message.
     * @param initialPacket
     * @return
     * @throws TlsProtocolException when the first message is not a ClientHello
     */
    private boolean checkClientHelloComplete(InitialPacket initialPacket) throws TlsProtocolException, TransportError {
        for (QuicFrame frame: initialPacket.getFrames()) {
            if (frame instanceof CryptoFrame) {
                cryptoBuffer.add((CryptoFrame) frame);
            }
        }

        if (cryptoBuffer.getBufferedMessagesCount() > 0) {
            if (cryptoBuffer.getBufferedMessages().get(0) instanceof ClientHello) {
                return true;
            } else {
                throw new TlsProtocolException("Unexpected message received: " + cryptoBuffer.getBufferedMessages().get(0));
            }
        }
        else {
            return false;
        }
    }

    /**
     * Check whether an initial packet makes sense as a first flight, to avoid building up state for malicious
     * connection creation attempts.
     * @param initialPacket
     * @throws UnacceptablePacketException
     */
    private void checkGenuineFirstFlight(InitialPacket initialPacket) throws UnacceptablePacketException {
        List<QuicFrame> frames = initialPacket.getFrames();
        // According to https://www.rfc-editor.org/rfc/rfc9000.html#section-12.4, initial packets may contain: PADDING,
        // PING, ACK, CRYPTO, CONNECTION_CLOSE. However, in the first flight, ACK and CONNECTION_CLOSE do not make sense,
        // neither do multiple PING frames (even one doesn't make much sense, but won't harm).
        boolean acceptableFrames = (frames.stream().allMatch(f -> f instanceof CryptoFrame || f instanceof PingFrame || f instanceof Padding));
        int nrOfPingFrames = (int) frames.stream().filter(f -> f instanceof PingFrame).count();
        if (!acceptableFrames || nrOfPingFrames > 12) {  // Chrome often sends multiple PING frames in the first flight
            throw new UnacceptablePacketException("Initial packet contains unacceptable frames");
        }
    }

    private void createAndRegisterServerConnection(InitialPacket initialPacket, PacketMetaData metaData, ByteBuffer datagramData, int receivedDataSize) {
        Version quicVersion = initialPacket.getVersion();
        byte[] originalDcid = initialPacket.getDestinationConnectionId();

        registrationLock.lock();
        try {
            if (!closed) {
                ServerConnectionImpl connection = serverConnectionFactory.createNewConnection(quicVersion, clientAddress, initialPacket.getSourceConnectionId(), originalDcid, null);

                // Pass the initial packet for processing, so it is processed on the server thread (enabling thread confinement concurrency strategy)
                ServerConnectionProxy connectionThread = serverConnectionFactory.createServerConnectionProxy(connection, bufferedInitialPackets, datagramData, metaData);
                connection.increaseAntiAmplificationLimit(receivedDataSize);

                // Register new connection with the new connection id (the one generated by the server)
                connectionRegistry.registerConnection(connectionThread, connection.getInitialConnectionId());
                registeredConnection = connectionThread;
            }
        }
        finally {
            registrationLock.unlock();
        }
    }

    @Override
    public boolean isClosed() {
        return false;
    }

    @Override
    public void closeConnection() {
        registrationLock.lock();
        try {
            if (registeredConnection != null) {
                registeredConnection.closeConnection();
            }
            closed = true;
        }
        finally {
            registrationLock.unlock();
        }
    }

    @Override
    public void dispose() {
    }

    InitialPacket parseInitialPacket(int datagramNumber, Instant timeReceived, ByteBuffer data) throws InvalidPacketException, DecryptionException, TransportError {
        // Note that the caller already has extracted connection id's from the raw data, so checking for minimal length is not necessary here.
        int flags = data.get();
        int packetVersion = data.getInt();
        data.rewind();

        if ((flags & 0x40) != 0x40) {
            // https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-17.2
            // "Fixed Bit:  The next bit (0x40) of byte 0 is set to 1, unless the packet is a Version Negotiation packet.
            //  Packets containing a zero value for this bit are not valid packets in this version and MUST be discarded."
            throw new InvalidPacketException();
        }

        if (packetVersion != quicVersion.getId()) {
            // As the server did not yet respond to the client, the client must still use the same version.
            throw new InvalidPacketException();
        }

        // https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-17.2
        // "The most significant bit (0x80) of byte 0 (the first byte) is set to 1 for long headers."
        // https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-17.2.2
        // "An Initial packet uses long headers with a type value of 0x0."
        if (InitialPacket.isInitialType((flags & 0x30) >> 4, quicVersion)) {
            InitialPacket packet = new InitialPacket(quicVersion);
            ConnectionSecrets connectionSecrets = new ConnectionSecrets(new VersionHolder(quicVersion), Role.Server, null, new NullLogger());
            byte[] originalDcid = dcid;
            connectionSecrets.computeInitialKeys(originalDcid);
            try {
                Aead aead = connectionSecrets.getPeerAead(packet.getEncryptionLevel());
                packet.parse(data, aead, 0, new NullLogger(), 0);
                return packet;
            } catch (MissingKeysException e) {
                // Impossible, as initial keys have just been computed.
                throw new RuntimeException(e);
            }
        }
        throw new InvalidPacketException();
    }

    private void removeFromConnectionRegistry() {
        // If no connection is created in the meantime, remove the candidate from the registry.
        registrationLock.lock();
        try {
            if (registeredConnection == null) {
                connectionRegistry.deregisterConnection(this, dcid);
            }
        } finally {
            registrationLock.unlock();
        }
    }

    @Override
    public String toString() {
        return "ServerConnectionCandidate[" + Bytes.bytesToHex(dcid) + "]";
    }
}
